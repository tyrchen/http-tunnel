构建基于 Rust 和 AWS Lambda 的类 ngrok 隧道服务：一份全面的架构设计报告第一部分：架构基础与核心设计第 1 节：解构现代隧道服务现代软件开发，尤其是在涉及 Webhook、API 集成和移动后端测试的场景中，开发者常常面临一个核心挑战：如何将运行在本地开发环境中的服务安全、便捷地暴露给公共互联网进行测试和验证 1。本地网络通常位于网络地址转换（NAT）或防火墙之后，这使得外部服务无法直接访问本地运行的应用程序 3。为了解决这一问题，以 ngrok 和 localtunnel 为代表的隧道服务应运而生，它们提供了一种无需复杂网络配置（如端口转发或DNS修改）即可实现本地服务公网访问的解决方案 4。1.1 核心问题：穿越 NAT 和防火墙互联网的基本工作原理是端到端通信，但出于安全和 IPv4 地址耗尽等原因，大多数开发环境都位于私有网络中。路由器使用 NAT 技术将多个私有 IP 地址映射到一个公共 IP 地址，从而实现了对内网设备的保护 1。这种机制虽然有效，但也阻止了从公共互联网到特定内网设备的入站连接请求。隧道服务的首要任务就是巧妙地绕过这些限制 3。1.2 客户端-服务器“反向隧道”模式所有主流隧道服务的架构都基于一个共同的模式：客户端-服务器“反向隧道” 5。该模式包含三个核心组件：代理（Agent）：一个轻量级的命令行程序或软件开发工具包（SDK），与本地需要暴露的服务并行运行 7。代理负责与云端的隧道服务器建立和维护通信。服务器（Server）：一个部署在全球可访问的云基础设施上的服务端点。它充当公共互联网流量的入口和反向代理，为每个隧道会话分配一个唯一的公共 URL 7。隧道（Tunnel）：代理主动向服务器发起并维持一个或多个持久化的出站连接。这些连接通常使用 TLS 加密，并通过标准的网络端口（如 443）进行通信 5。由于连接是由内网的代理发起的，它可以自然地穿透 NAT 和防火墙，因为大多数网络策略允许出站连接。这种由内向外的连接方式是整个机制的关键，它颠覆了传统的服务器监听入站连接的模式。这种架构的精妙之处在于，它将连接建立的责任从无法触及内网的服务器转移到了能够访问公网的代理客户端。localtunnel 的实现中，代理在注册后会与服务器建立并维持多达 10 个 TCP 连接池，以实现并发请求的处理 5。同样，ngrok 也强调其代理通过“安全、出站的持久性 TLS 连接”与云服务通信 7。这种连接池或持久连接的设计并非偶然，它解决了单一连接可能成为性能瓶颈的问题，允许系统通过多路复用技术高效处理多个并发的公共请求，而无需等待单一的 TCP 流释放。这直接影响了我们后续客户端代理的设计复杂性，提示我们不仅要考虑建立连接，更要考虑如何管理一个有韧性、高性能的连接策略。1.3 数据流分析一个典型的请求生命周期如下：外部请求：互联网上的用户或服务向隧道服务分配的公共 URL（例如 <https://unique-id.our-service.com）发送一个> HTTPS 请求。服务器接收：隧道服务器接收到该请求。流量转发：服务器通过预先建立的持久连接，将该请求准确地转发给对应的代理 5。本地代理处理：代理接收到请求后，将其转发给本地运行的服务（例如 <http://localhost:3000）。本地服务响应：本地服务处理请求并生成一个响应，然后将其返回给代理。响应回传：代理通过同一条持久连接将响应数据回传给服务器。最终响应：服务器再将此响应中继给最初发起请求的外部用户。通过这一流程，隧道服务在本地开发环境和公共互联网之间架起了一座无缝的桥梁，极大地简化了开发和测试工作流程> 9。第 2 节：Serverless 架构的诉求与挑战在设计新的技术服务时，Serverless（无服务器）计算模型，特别是 AWS Lambda，因其独特的优势而备受青睐。用户在请求中明确提出将服务部署为 Lambda 函数，这反映了对成本效益、可扩展性和运维简便性的追求。2.1 Serverless 架构的吸引力选择 AWS Lambda 作为后端计算平台的动机显而易见：成本效益：Lambda 采用按调用次数和执行时长计费的模式。对于使用场景不频繁或呈突发性的测试工具而言，这意味着在没有流量时几乎不产生任何费用，实现了成本的极致优化 10。自动扩展：Lambda 平台能够根据请求量自动、即时地扩展计算实例，无需任何手动配置或容量规划。运维简化：开发者只需关注业务逻辑代码，无需管理底层服务器、操作系统或运行时环境，极大地降低了运维负担。2.2 根本性的架构不匹配然而，隧道服务的核心需求与 AWS Lambda 的基本特性之间存在着深刻的、根本性的冲突。隧道服务器的需求：它必须是一个长期运行的、有状态的进程。它需要能够同时接收并维持来自成百上千个代理的持久性 TCP/TLS 连接，这些连接的生命周期可能长达数小时甚至数天。AWS Lambda 的特性：无状态性：每次 Lambda 调用都在一个全新的、隔离的环境中执行，两次调用之间不共享内存或本地状态。生命周期短暂：单次 Lambda 调用的最长执行时间被严格限制在 15 分钟以内 12。更重要的是，如果通过标准的 API Gateway HTTP API 触发 Lambda，其集成超时时间上限仅为 29 秒 15。这种特性决定了任何试图在单个 Lambda 调用中维持一个长期连接的方案都是不可行的。一个标准的 Lambda 函数无法承担起传统服务器“永远在线”的角色。用户的部署要求揭示了一个潜在的技术认知偏差，或者是一种对创新架构的探索。我们的任务不是要强行让 Lambda 变得有状态，而是要将状态管理的责任巧妙地转移到专为此类场景设计的其他 AWS 服务上。2.3 明确设计难题因此，本次架构设计的核心难题可以被精确地定义为：如何利用由无状态、短生命周期的计算单元（AWS Lambda）组成的后端，构建一个对客户端代理而言表现为有状态、持久连接的服务？解决这一难题的关键在于识别 AWS 生态系统中能够弥合这一差距的组件。Lambda 的执行时长限制 14 直接否定了“在 Lambda 中运行一个传统服务器”的简单思路。然而，AWS 的服务组合中已经包含了解决“为 Serverless 应用提供持久连接”这一问题的答案：API Gateway WebSocket API 16。该服务正是连接持久连接世界与事件驱动 Serverless 世界的桥梁，它将作为我们架构设计的基石。第 3 节：推荐架构：API Gateway WebSocket 桥接模型为了解决上述的架构不匹配问题，我们提出一种基于 API Gateway WebSocket API 的桥接模型。该架构巧妙地利用了 AWS 托管服务来处理持久连接和状态管理，同时将核心业务逻辑保留在由事件驱动的 Rust Lambda 函数中。3.1 高层架构概览该架构的核心思想是：使用 API Gateway WebSocket API 作为有状态的连接代理。这项服务专门用于管理大规模的持久性 WebSocket 连接，并在连接生命周期的关键事件（如连接、断开、消息接收）发生时，触发后端的计算服务（如 Lambda） 17。3.2 核心组件及其角色本架构由以下关键的 AWS 服务组成：Route 53 & AWS Certificate Manager (ACM)：提供自定义的、用户友好的公共 HTTPS 端点（例如 tunnel.your-domain.com），并自动管理 TLS 证书，确保通信安全 20。API Gateway (HTTP API)：作为面向公众的流量入口，接收来自互联网的 HTTPS 请求。它不直接与代理通信，而是将请求转发给后端的“转发 Lambda 函数”。API Gateway (WebSocket API)：作为服务内部的“控制平面”端点，供 Rust 代理客户端连接。它负责维持与代理之间的持久性 WebSocket 连接，并管理隧道的整个生命周期 16。AWS Lambda Functions (Rust)：一组独立的、由事件驱动的 Rust 函数，负责处理核心业务逻辑，包括连接管理和请求转发 19。Amazon DynamoDB：一个高性能的键值数据库，用作系统的状态存储。它是整个架构的“大脑”，负责记录活跃的代理连接，并将公共请求精确地映射到特定的隧道 17。3.3 系统架构图图注：上图展示了控制平面（代理连接）和数据平面（公共请求处理）的完整数据流。代理通过 WebSocket API 建立持久连接，其状态记录在 DynamoDB 中。公共 HTTPS 请求通过 HTTP API 触发 Lambda，Lambda 查询 DynamoDB 找到对应的代理连接，并通过 WebSocket API 将请求转发下去。3.4 重新定义的数据流在这种新架构下，数据流被清晰地划分为两个独立的平面：控制平面（代理连接与管理）：Rust 代理向 API Gateway WebSocket 端点发起一个持久的 WebSocket 连接请求。API Gateway 接收连接，触发 $connect 路由，并调用关联的 ConnectHandler Lambda 函数。该 Lambda 函数为代理生成一个唯一的公共子域名，并将 API Gateway 分配的 connectionId 与该子域名一同存入 DynamoDB 表中，完成注册。数据平面（公共请求处理）：外部用户向分配给代理的公共子域名（例如 https://abc123xyz.tunnel.your-domain.com）发送一个 HTTPS 请求。该请求被 Route 53 解析，并路由到 API Gateway HTTP API。HTTP API 接收请求，并调用 ForwardingHandler Lambda 函数，将完整的 HTTP 请求作为事件负载传递。ForwardingHandler Lambda 从请求头中提取子域名，并以此为索引查询 DynamoDB，找到对应的 connectionId。Lambda 使用 AWS SDK 调用 API Gateway Management API 的 PostToConnection 接口，将序列化后的 HTTP 请求通过指定的 WebSocket 连接发送给代理 26。代理接收到 WebSocket 消息，将其解析并转发给本地服务。本地服务处理完毕后，代理将 HTTP 响应序列化，并通过 WebSocket 连接回传给服务器。此消息触发 WebSocket API 的 $default 路由，调用 ResponseHandler Lambda。ResponseHandler Lambda 负责将响应数据传递回正在等待的 ForwardingHandler Lambda，最终由 HTTP API 返回给外部用户。这种架构将服务清晰地分解为有状态的控制平面（由 API Gateway WebSocket API 管理）和完全无状态的数据平面（由 Lambda 水平扩展）。这种分离是一种强大且可扩展的设计模式。最初可能会设想用一个 API Gateway 处理所有流量，但很快就会发现，一个传入的 HTTP 请求无法直接知道应该与哪个 WebSocket 连接通信。这就迫使我们引入一个计算层（Lambda），它能够执行有状态的查找（在 DynamoDB 中），并使用带外的 PostToConnection API 进行通信。这揭示了 DynamoDB 的必要性——它不仅仅是一个连接列表，更是连接两个独立平面的关键路由表。这种架构的复杂性正是采用 Serverless 模型所带来的直接结果，但它也赋予了系统极高的弹性和成本效率。第二部分：服务端架构与 Rust 实现第 4 节：配置 API Gateway WebSocket 端点API Gateway WebSocket API 是我们 Serverless 隧道服务架构的核心，它负责管理与客户端代理之间的所有持久连接。正确配置此端点是实现整个系统的第一步。4.1 创建 WebSocket API可以通过 AWS 管理控制台、AWS CLI 或基础设施即代码（IaC）工具（如 AWS SAM 或 CloudFormation）来创建 WebSocket API 17。在创建过程中，需要定义一个“路由选择表达式”（Route Selection Expression），例如 $request.body.action。这个表达式告诉 API Gateway 如何根据传入消息的内容将其路由到不同的后端集成 19。4.2 定义路由与集成WebSocket API 的行为由路由定义。我们需要配置以下几个关键路由：$connect：这是一个预定义的特殊路由，在每个新的客户端代理成功建立连接时触发。我们将此路由与 ConnectHandler Lambda 函数集成。此路由是代理注册和会话初始化的入口点 19。$disconnect：同样是预定义的特殊路由，在客户端连接断开时（无论是正常关闭还是异常断开）触发。我们将此路由与 DisconnectHandler Lambda 函数集成，用于执行资源清理操作 19。$default：这是一个捕获所有路由，当传入的消息不匹配任何其他自定义路由时，该路由将被触发。我们将它与 ResponseHandler Lambda 集成，用于处理从代理发送回来的、对公共请求的响应数据。这些预定义的路由，特别是 $connect 和 $disconnect，并非简单的便利功能，它们是整个分布式会话管理生命周期的基础。没有它们，系统将无法可靠地感知代理的加入和离开，从而导致 DynamoDB 中的状态数据变得陈旧和不准确。然而，需要注意的是，$disconnect 事件是一个“尽力而为”的通知。网络中断等异常情况可能导致该事件无法被触发。这就引出了一个更深层次的问题：如何处理“僵尸”连接。解决方案不在于 API Gateway 本身，而在于我们接下来要讨论的 DynamoDB 设计中，即必须引入一种自动化的垃圾回收机制。4.3 自定义域名与 TLS为了提供专业且易于记忆的连接端点，我们需要为其配置自定义域名。申请 TLS 证书：在 AWS Certificate Manager (ACM) 中为您的自定义域名（例如 agent-api.your-service.com）申请一个公共的 SSL/TLS 证书。ACM 会自动处理证书的续期 20。创建自定义域名：在 API Gateway 控制台中，创建一个新的“自定义域名”，并将其与刚刚在 ACM 中申请的证书关联起来 29。API 映射：将创建的自定义域名映射到 WebSocket API 的特定部署阶段（例如 prod）。配置 DNS 解析：在 Route 53 中，为您的自定义域名创建一个 ALIAS 记录，将其指向 API Gateway 自动生成的端点域名。ALIAS 记录是 AWS 推荐的方式，因为它能自动适应底层 IP 地址的变化 31。完成这些步骤后，您的 Rust 代理就可以通过 wss://agent-api.your-service.com 这样的友好地址来连接服务了。第 5 节：使用 DynamoDB 进行连接状态管理由于 Lambda 函数是无状态的，我们必须借助外部存储来持久化代理的连接信息。Amazon DynamoDB 因其 Serverless 特性、低延迟的键值访问能力以及与 Lambda 的无缝集成，成为本架构的理想选择 24。5.1 为何选择 DynamoDB？DynamoDB 的特性与我们的 Serverless 架构完美契合。它提供按需容量模式，可以根据负载自动伸缩，并且与 Lambda 之间通过 IAM 角色进行安全、高效的通信。这使得我们能够构建一个完全 Serverless 的状态管理层。5.2 数据表结构设计我们需要设计一个 DynamoDB 表来存储所有活跃的连接信息。表名：agent_connections分区键（Primary Key）：connectionId (类型: String)。这是 API Gateway 在客户端连接时生成的唯一标识符，作为每条记录的主键是自然而然的选择 19。核心属性：publicSubdomain (类型: String)：在连接时为代理生成的唯一公共子域名（例如 "abc123xyz"）。creationTimestamp (类型: Number)：连接建立时的 Unix 时间戳，用于审计和监控。ttl (类型: Number)：用于 DynamoDB TTL（Time-to-Live）功能的 Unix 时间戳。5.3 为高效查询建立索引当一个公共 HTTPS 请求到达 ForwardingHandler Lambda 时，它只知道请求的子域名（publicSubdomain），但需要 connectionId 才能将数据通过 WebSocket 推送给代理。为了实现从 publicSubdomain 到 connectionId 的高效查找，避免昂贵的全表扫描操作，我们必须创建一个全局二级索引（Global Secondary Index, GSI）。GSI 名称：subdomain-indexGSI 分区键：publicSubdomain投影属性：仅投影 connectionId 即可，以最小化存储和读取成本。这种主键和 GSI 的设计体现了系统的双重访问模式：我们基于 connectionId（API Gateway 的自然键）进行写入和删除操作，但基于 publicSubdomain（公共数据平面的业务键）进行读取操作。因此，DynamoDB 的表结构设计不仅仅是数据存储方案，它直接定义了整个系统的核心路由逻辑。5.4 实现自动化的连接清理（TTL）如前所述，$disconnect 事件并不能保证 100% 触发。为了防止数据库中积累大量无效的“僵尸”连接记录，我们必须启用 DynamoDB 的 Time-to-Live (TTL) 功能 15。配置：在 agent_connections 表上启用 TTL，并指定 ttl 属性作为过期时间戳。工作原理：当 ConnectHandler Lambda 创建一条新的连接记录时，它会计算一个未来的过期时间（例如，当前时间 + 2小时），并将其写入 ttl 属性。DynamoDB 的后台进程会定期扫描并自动删除 ttl 时间戳已过期的项目，且此删除操作不消耗任何预置或按需的写入容量单位。这为我们提供了一个免费、可靠的垃圾回收机制。第 6 节：使用 Rust Lambda 函数实现核心逻辑我们将使用 Rust 语言和 aws-lambda-rust-runtime 生态系统来编写 Lambda 函数，以获得高性能和内存安全的优势。cargo-lambda 工具链可以极大地简化 Rust Lambda 的构建、打包和部署流程 22。6.1 ConnectHandler 函数（$connect 路由）此函数是代理生命周期的起点。触发：由 API Gateway 的 $connect 事件触发。逻辑：从传入的 ApiGatewayWebsocketProxyRequest 事件中，解析出 requestContext.connectionId。生成一个全局唯一的、不易被猜测的随机字符串作为 publicSubdomain。计算 TTL 过期时间戳，例如 SystemTime::now() + Duration::from_secs(2 * 3600)。使用 AWS SDK for Rust (aws-sdk-dynamodb)，向 agent_connections 表中写入一个新项目，包含 connectionId、publicSubdomain 和 ttl。返回一个 HTTP 200 OK 响应给 API Gateway，表示连接已成功处理。6.2 DisconnectHandler 函数（$disconnect 路由）此函数负责清理工作。触发：由 API Gateway 的 $disconnect 事件触发。逻辑：从事件中解析出 requestContext.connectionId。使用 AWS SDK for Rust，向 DynamoDB 发送一个 DeleteItem 请求，以 connectionId 为键删除对应的连接记录。返回一个 HTTP 200 OK 响应。6.3 ForwardingHandler 与 ResponseHandler 函数这组函数构成了数据平面的核心，也是整个架构中最具挑战性的部分。它们需要解决一个核心问题：如何在一个同步的 HTTP 请求-响应周期内，桥接一个本质上异步的 WebSocket 消息来回。ForwardingHandler (由 HTTP API 触发)：接收来自公共 API Gateway 的完整 HTTP 请求事件。从请求的 Host 头中解析出 publicSubdomain。使用 subdomain-index GSI 查询 DynamoDB，获取与该子域名关联的 connectionId。将整个 HTTP 请求（方法、URI、头、主体）序列化为一个定义好的 JSON 负载（详见第 9 节）。使用 AWS SDK for Rust (aws-sdk-apigatewaymanagement) 调用 PostToConnection API，将 JSON 负载发送给目标 connectionId。等待响应：PostToConnection 是一个“即发即忘”的操作。ForwardingHandler 必须暂停执行，等待代理通过 WebSocket 返回响应。这是一个巨大的挑战，因为两个 Lambda 调用（ForwardingHandler 和 ResponseHandler）之间没有直接的通信渠道。ResponseHandler (由 WebSocket $default 路由触发)：代理将本地服务的响应作为 WebSocket 消息发送回来。API Gateway 捕获此消息，并触发 ResponseHandler Lambda。此 Lambda 的任务是将收到的响应数据安全地传递回正在等待的 ForwardingHandler。解决异步通信的桥接方案：由于两个 Lambda 调用之间无法直接通信，我们必须引入一个中间协调机制。一个可行的方案是：在 ForwardingHandler 中，生成一个唯一的 requestId。在调用 PostToConnection 之前，将这个 requestId 和 connectionId 一同写入 DynamoDB 的一个新表（或现有表的新属性）中，标记为“等待中”。ForwardingHandler 进入一个轮询循环，以短暂的间隔（例如 100 毫秒）查询 DynamoDB 中该 requestId 的状态。当 ResponseHandler 被触发时，它从代理返回的消息中解析出 requestId 和响应数据，然后更新 DynamoDB 中对应 requestId 的记录，将状态标记为“已完成”并存入响应数据。ForwardingHandler 的轮询检测到状态变化，读取响应数据，并将其作为 HTTP 响应返回。这个过程揭示了 Serverless 架构的复杂性：为了维持表面的简单性，底层需要构建一个复杂的、基于数据库的自定义请求-响应关联机制来协调分布式组件。第三部分：Rust 客户端代理客户端代理是连接用户本地开发环境与云端服务的关键组件。它必须是一个健壮、高效且可靠的后台进程。第 7 节：本地代理设计7.1 核心职责代理软件需要承担以下几项核心任务：建立与维护连接：与云端的 API Gateway WebSocket 端点建立一个持久的 WebSocket 连接。自动重连：在遇到网络中断、服务器重启等导致连接断开的情况下，必须实现自动重连逻辑。一个健壮的实现会采用指数退避（Exponential Backoff）策略，以避免在网络故障时对服务器造成冲击。监听与转发：异步地监听来自服务器的 WebSocket 消息（即被转发的公共 HTTP 请求）。本地代理：作为一个 HTTP 客户端，将收到的请求转发给用户在本地指定的端口（例如 localhost:8080）。响应回传：获取本地服务的 HTTP 响应，并将其通过 WebSocket 连接回传给服务器。7.2 应对空闲超时API Gateway WebSocket 连接存在一个 10 分钟的空闲超时限制 34。如果在一个 10 分钟的窗口内，连接上没有任何数据传输，API Gateway 将会主动断开该连接。为了维持隧道的持久性，代理必须实现一个心跳（Heartbeat）机制。实现方式：代理需要启动一个定时器，例如每 5 分钟，通过 WebSocket 连接向服务器发送一个“心跳”消息。这个消息可以是一个标准的 WebSocket Ping 帧，也可以是一个自定义的 JSON 消息，如 {"type": "ping"}。服务器端不需要对这个消息做特殊处理，只要有数据流经连接，API Gateway 就会重置其空闲计时器。第 8 节：使用 Tokio 和 Tungstenite 实现 Rust 代理Rust 的异步生态系统，特别是 tokio 运行时和 tokio-tungstenite 库，为构建高性能网络应用提供了强大的工具。8.1 项目依赖在 Cargo.toml 文件中，我们需要添加以下关键依赖：tokio：提供异步运行时、任务调度和 I/O 工具。tokio-tungstenite：提供基于 tokio 的异步 WebSocket 客户端实现 35。hyper 或 reqwest：用于向本地服务发起 HTTP 请求。hyper 更底层、性能更高，reqwest 则提供了更便捷的 API 38。serde 和 serde_json：用于序列化和反序列化我们在第 9 节中定义的 JSON 通信协议。url：用于解析 WebSocket 连接的 URL。8.2 建立连接使用 tokio_tungstenite::connect_async 函数可以轻松地与我们的 wss:// 端点建立连接。该函数会异步地完成 TCP 连接和 WebSocket 握手过程 37。8.3 主异步循环一个健壮的代理会利用 tokio 的并发能力，将不同的任务分离到独立的异步任务中：连接管理任务：一个顶层的循环，负责调用 connect_async。如果连接成功，它将 WebSocket 流（WebSocketStream）分割为独立的读（Stream）和写（Sink）两半 36。然后，它会为读、写和心跳逻辑分别 tokio::spawn 新的任务。如果连接断开，这个任务会根据指数退避策略等待一段时间后再次尝试连接。消息读取任务：这个任务循环地从 WebSocket 的读半部分（Stream）接收消息。当收到一个代表 HTTP 请求的消息时，它会将其分派给一个新的代理任务去处理。消息写入任务：这个任务通过一个 tokio::sync::mpsc 通道接收来自其他任务（如代理任务或心跳任务）准备发送的消息，并将它们写入 WebSocket 的写半部分（Sink）。心跳任务：一个简单的循环，使用 tokio::time::interval 每隔固定时间（如 5 分钟）就向消息写入任务的通道发送一个心跳消息。这种基于任务和通道的解耦设计，可以防止任何一个环节的阻塞影响到其他环节。例如，一个响应缓慢的本地服务不会阻止代理接收来自服务器的新的请求。8.4 代理逻辑实现当消息读取任务收到一个请求消息后，具体的代理逻辑如下：使用 serde_json 将接收到的 WebSocket 文本消息反序列化为我们定义的请求结构体。根据结构体中的信息（方法、URI、头、主体），使用 hyper 构建一个新的 http::Request 对象。使用 hyper::Client 将此请求发送到用户指定的本地地址（例如 http://127.0.0.1:3000）。await 来自本地服务的 http::Response。将响应的各部分（状态码、头、主体）提取出来，构建成我们定义的响应结构体。使用 serde_json 将响应结构体序列化为 JSON 字符串。将此 JSON 字符串封装成一个 tokio_tungstenite::tungstenite::Message::Text，并将其发送到消息写入任务的通道，由其最终发送回服务器。第 9 节：数据序列化与协议定义由于 WebSocket 是一个面向消息的协议，我们不能直接在其上传输原始的 HTTP 字节流。必须将每个 HTTP 请求和响应完整地封装在单个 WebSocket 消息中。JSON 因其通用性和易于在 Rust 中处理（通过 serde）而成为理想的格式选择。9.1 请求负载（服务器 -> 代理）从云端服务器发送到本地代理的每个消息都应包含一个完整的 HTTP 请求信息。定义一个 Rust 结构体并使用 serde 进行序列化：JSON{
  "requestId": "a-unique-uuid-generated-by-forwarding-lambda",
  "method": "POST",
  "uri": "/api/v1/users?param=value",
  "headers": {
    "Content-Type": ["application/json"],
    "X-Custom-Header": ["value1"]
  },
  "body": "eyJrZXkiOiAidmFsdWUifQ=="
}
requestId：由 ForwardingHandler Lambda 生成的唯一标识符，用于将响应与原始请求关联起来。headers：使用一个数组来表示值，因为 HTTP 头可以有多个相同键的值。body：请求体应使用 Base64 编码，以安全地传输二进制数据。9.2 响应负载（代理 -> 服务器）代理在从本地服务获得响应后，将其构造成如下格式的 JSON 负载发送回服务器：JSON{
  "requestId": "a-unique-uuid-generated-by-forwarding-lambda",
  "statusCode": 201,
  "headers": {
    "Content-Type": ["application/json"],
    "Location": ["/api/v1/users/123"]
  },
  "body": "eyJpZCI6IDEyMywgIm5hbWUiOiAiSm9obiBEb2UifQ=="
}
requestId：必须与收到的请求中的 requestId 相同，以便服务器端的 ResponseHandler 能够将其与正确的等待中请求关联起来。body：响应体同样使用 Base64 编码。9.3 控制消息为了心跳和其他可能的控制信令，可以定义一个简单的信封结构：JSON{
  "type": "ping"
}
这允许代理和服务器在未来扩展其控制协议，而不会与数据传输协议混淆。第四部分：安全、替代方案与最终建议第 10 节：多层安全策略构建一个暴露本地服务的工具，安全性是设计的重中之重。我们必须在架构的每个层面都实施严格的安全控制。10.1 代理认证：核心防御层阻止未经授权的客户端连接到我们的 WebSocket 后端是首要任务。我们将通过为 API Gateway WebSocket API 配置一个 Lambda Authorizer 来实现这一点 41。实现机制：创建一个专门的 Lambda 函数（Authorizer Lambda），并将其附加到 WebSocket API 的 $connect 路由上。要求每个代理在发起 WebSocket 连接请求时，必须提供一个身份验证凭证。一个常见的做法是使用 JSON Web Token (JWT)。代理可以先通过一个独立的、受保护的 REST API 端点（例如 /login）进行身份验证，以获取一个有时效性的 JWT。代理在连接时，将此 JWT 通过查询字符串参数（例如 wss://.../?token=YOUR_JWT）或请求头传递 42。虽然我们的 Rust 客户端可以设置请求头，但考虑到浏览器 WebSocket API 的限制（无法自定义头），使用查询字符串参数是更具通用性和前瞻性的选择 43。API Gateway 在处理 $connect 请求前，会先调用 Authorizer Lambda，并将包含凭证的请求信息传递给它。Authorizer Lambda 负责验证 JWT 的签名、有效期和声明。验证通过后，它会生成并返回一个 IAM 策略文档，明确允许（"Effect": "Allow"）或拒绝（"Effect": "Deny"）对该 WebSocket API 的访问 42。将 Authorizer 附加到 $connect 路由是一个强大的杠杆点。它在连接建立的最初阶段就对所有流量进行了安全审查。一旦连接被拒绝，任何后续的消息都无法发送，从而在服务边界处就切断了恶意行为者，有效保护了后端的计算和数据库资源 46。10.2 最小权限原则（IAM）为每个 Lambda 函数配置精确且最小化的 IAM 角色是至关重要的安全实践。ConnectHandler：仅需要对 agent_connections DynamoDB 表的 dynamodb:PutItem 权限。DisconnectHandler：仅需要 dynamodb:DeleteItem 权限。ForwardingHandler：需要对 agent_connections 表的 dynamodb:Query 权限（通过 GSI），以及 apigatewaymanagement:PostToConnection 权限，以向代理发送消息。ResponseHandler：需要对用于请求-响应协调的 DynamoDB 表的 dynamodb:UpdateItem 权限。Authorizer Lambda：通常不需要访问其他 AWS 资源，除非需要从 Secrets Manager 等服务中获取 JWT 验证密钥。10.3 端到端加密数据在整个传输链路中都应被加密：外部用户到 HTTP API：通过 HTTPS (TLS) 加密。代理到 WebSocket API：通过 WSS (TLS) 加密。API Gateway 到 Lambda：流量在 AWS 的私有网络内部传输，并默认加密。Lambda 到 DynamoDB：通过 TLS 加密。整个数据路径都受到传输中加密的保护，确保了数据的机密性。第 11 节：替代架构：基于 AWS Fargate 的容器化方案尽管 Serverless 架构具有诸多优势，但其固有的复杂性也值得我们审视。为了提供一个全面的视角，我们设计一个基于容器的替代方案，它采用更传统的应用模型，但仍然受益于 AWS 的托管服务，避免了直接管理 EC2 实例的麻烦 10。11.1 替代方案的理由对于需要更长连接生命周期、更低延迟或更简化状态管理的场景，基于容器的架构可能更为合适。AWS Fargate 是一个 Serverless 容器计算引擎，它允许我们运行容器而无需管理底层的服务器 10。11.2 架构概览核心应用：一个单一的、长期运行的 Rust 应用程序，被打包在一个 Docker 容器中。功能集成：这个应用程序将同时承担起传统 Web 服务器和 WebSocket 服务器的职责。它会直接监听公共 HTTPS 流量，并管理与代理之间的持久 WebSocket（或原始 TCP）连接。所有的连接状态都将保存在应用程序的内存中。部署模型：该容器将作为一项 AWS Fargate 服务进行部署，并置于一个 Application Load Balancer (ALB) 之后。流量路由：ALB 负责处理 TLS 终止、健康检查，并将来自公网的 HTTP 和 WebSocket 流量路由到后端的 Fargate 任务实例。11.3 优势逻辑简化：无需 DynamoDB 进行状态管理，因为所有连接状态都保存在应用内存中。也无需设计复杂的 Lambda 间通信机制。整个应用的逻辑更加内聚和传统。性能可预测：没有 Lambda 冷启动问题，这意味着请求延迟更低且更一致。协议灵活性：开发者可以完全控制网络协议栈，可以选择原始 TCP 隧道而非 WebSocket，并实现自定义的保活逻辑。11.4 劣势成本模型：Fargate 按 vCPU 和内存资源的预留量按秒计费，只要任务在运行，无论是否有流量，都会持续产生费用。对于流量稀疏的测试工具来说，这远不如 Lambda 的按需付费模型经济 47。运维开销：虽然免去了服务器管理，但仍需编写和维护 Dockerfile，在 Amazon ECR 中管理容器镜像，以及配置 Fargate 任务定义和服务。扩展性：扩展是通过增减容器任务实例来实现的，这个过程比 Lambda 的按请求扩展要慢，粒度也更粗。第 12 节：架构对比分析与建议选择最佳架构取决于具体的业务需求、性能要求和成本限制。用户的核心用例——“用作测试之用”——是指导我们做出最终建议的最重要因素。12.1 关键决策矩阵为了直观地比较这两种架构，我们构建了以下决策矩阵：表：架构权衡：Serverless (API Gateway/Lambda) vs. 容器化 (Fargate)指标Serverless (API Gateway/Lambda)容器化 (Fargate)理由与依据成本模型按请求/GB-秒/连接分钟付费。可扩展至零成本。对于低流量或间歇性流量极为经济。按预留的 vCPU/GB-秒付费。无论流量如何，成本相对恒定。对于高且持续的流量更具成本效益。49 用户的“测试”目的意味着间歇性使用，这使得 Serverless 的成本模型具有压倒性优势。可扩展性大规模并行，按请求自动扩展。数据平面具有近乎“无限”的理论扩展能力。通过增减容器任务进行扩展。扩展速度较慢。更适合可预测的稳定工作负载。10 Lambda 的扩展模型对于开发和测试中常见的突发性、不可预测的流量模式更为优越。性能首次调用或不频繁调用时存在“冷启动”导致的高延迟。对于“温”函数，延迟较低。延迟始终较低且一致（“永远在线”）。无冷启动惩罚。13 冷启动是 Lambda 模型的主要性能短板。对于测试工具而言，这种偶尔的延迟通常是可以接受的权衡。运维开销接近于零。无服务器、无容器、无操作系统补丁。开发者只需关注函数代码和 IAM 角色。较低，但非零。需要管理 Dockerfile、ECR 仓库和 Fargate 任务定义。10 Serverless 模型从根本上减少了开发者的运维责任范围。连接处理由 API Gateway 抽象管理。受 AWS 的限制（如 10 分钟空闲超时，2 小时最大连接时长）。在应用程序内直接控制。可支持任意长的连接和自定义的保活逻辑。14 Fargate 模型提供了更多控制权，但需要更多实现工作。Serverless 模型的限制对于大多数测试场景是足够的。开发复杂性架构复杂性高。需要理解分布式系统、事件驱动模式和多个 AWS 服务（API GW、Lambda、DynamoDB）。架构复杂性低。更传统的单体服务器应用模型。状态在内存中管理。Serverless 方案需要在三个服务和两种协议之间建立请求关联，其心智模型比单个 Fargate 应用要复杂得多。第 13 节：结论13.1 发现总结本报告详细设计了两种截然不同的架构方案，用于构建一个基于 Rust 的类 ngrok 隧道服务。Serverless 架构：利用 API Gateway、Lambda 和 DynamoDB，构建了一个高度可扩展、运维成本极低且在间歇性使用场景下极具成本效益的系统。其主要挑战在于较高的架构复杂性和需要精心设计的分布式状态管理。容器化架构：利用 AWS Fargate，提供了一个更传统、开发模型更简单的方案。它通过在内存中管理状态来降低逻辑复杂性，并提供一致的低延迟性能，但其成本模型不适合低流量场景。13.2 最终建议对于用户明确提出的**“用作测试之用”**这一核心目标，我们强烈推荐采用基于 API Gateway、Lambda 和 DynamoDB 的 Serverless 架构。其按使用付费的成本模型与测试和开发的间歇性工作负载完美契合，可以确保在服务闲置时成本降至最低。此外，一旦部署完成，其近乎零的运维开销将使开发者能够专注于核心功能的迭代，而非基础设施的管理。尽管架构本身较为复杂，但这种一次性的设计投入将换来长期的成本和运维优势。13.3 未来展望需要指出的是，如果该服务未来演变为一个需要处理高吞吐量、持续性流量的生产级平台，那么迁移到基于 Fargate 的架构将是一个合乎逻辑的、值得推荐的演进路径。在那种规模下，Fargate 模型的固定成本和可预测的性能将变得更具吸引力。
