# Infrastructure as Code with Pulumi (TypeScript)

## Overview
This specification defines the complete AWS infrastructure deployment using Pulumi with TypeScript. The infrastructure includes API Gateways, Lambda functions, DynamoDB tables, and all necessary IAM roles and policies.

## Architecture Components

```
┌─────────────────────────────────────────────────────────────┐
│                        Route 53                             │
│  tunnel.example.com → CloudFront or API Gateway             │
└─────────────────────┬───────────────────────────────────────┘
                      │
        ┌─────────────┴──────────────┐
        ▼                            ▼
┌──────────────────┐        ┌──────────────────┐
│ HTTP API Gateway │        │ WebSocket API GW │
│  (Public HTTP)   │        │  (Agent Conn)    │
└────────┬─────────┘        └────────┬─────────┘
         │                           │
         ▼                           ▼
  ┌─────────────┐            ┌────────────────┐
  │ Forwarding  │            │ Connect        │
  │   Lambda    │            │ Disconnect     │
  └──────┬──────┘            │ Response       │
         │                   │ Lambdas        │
         └───────────┬───────┴────────────────┘
                     ▼
         ┌───────────────────────┐
         │     DynamoDB          │
         │  - connections        │
         │  - pending_requests   │
         └───────────────────────┘
```

## Project Structure

```
infra/
├── index.ts              # Main Pulumi program
├── package.json          # Node.js dependencies
├── tsconfig.json         # TypeScript configuration
├── Pulumi.yaml           # Pulumi project metadata
├── Pulumi.dev.yaml       # Dev stack configuration
├── Pulumi.prod.yaml      # Production stack configuration
└── src/
    ├── dynamodb.ts       # DynamoDB table resources
    ├── lambda.ts         # Lambda function resources
    ├── apigateway.ts     # API Gateway resources
    ├── iam.ts            # IAM roles and policies
    ├── domain.ts         # Custom domain and certificates
    └── config.ts         # Configuration and types
```

## Pulumi Configuration

### Pulumi.yaml
```yaml
name: http-tunnel
runtime: nodejs
description: HTTP Tunnel Service Infrastructure
```

### Pulumi.dev.yaml
```yaml
config:
  aws:region: us-east-1
  http-tunnel:domainName: tunnel.dev.example.com
  http-tunnel:environment: dev
  http-tunnel:lambdaArchitecture: x86_64
  http-tunnel:lambdaMemorySize: 256
  http-tunnel:enableCustomDomain: false
```

### Pulumi.prod.yaml
```yaml
config:
  aws:region: us-east-1
  http-tunnel:domainName: tunnel.example.com
  http-tunnel:environment: prod
  http-tunnel:lambdaArchitecture: arm64
  http-tunnel:lambdaMemorySize: 512
  http-tunnel:enableCustomDomain: true
  http-tunnel:certificateArn: arn:aws:acm:us-east-1:...
```

## Implementation

### src/config.ts
```typescript
import * as pulumi from "@pulumi/pulumi";

const config = new pulumi.Config();

export interface AppConfig {
  environment: string;
  domainName: string;
  enableCustomDomain: boolean;
  certificateArn?: string;
  lambdaArchitecture: "x86_64" | "arm64";
  lambdaMemorySize: number;
  lambdaTimeout: number;
  awsRegion: string;
}

export const appConfig: AppConfig = {
  environment: config.require("environment"),
  domainName: config.require("domainName"),
  enableCustomDomain: config.getBoolean("enableCustomDomain") ?? false,
  certificateArn: config.get("certificateArn"),
  lambdaArchitecture: (config.get("lambdaArchitecture") as "x86_64" | "arm64") ?? "x86_64",
  lambdaMemorySize: config.getNumber("lambdaMemorySize") ?? 256,
  lambdaTimeout: config.getNumber("lambdaTimeout") ?? 30,
  awsRegion: config.require("aws:region"),
};

export const tags = {
  Environment: appConfig.environment,
  Project: "http-tunnel",
  ManagedBy: "pulumi",
};
```

### src/dynamodb.ts
```typescript
import * as aws from "@pulumi/aws";
import * as pulumi from "@pulumi/pulumi";
import { tags } from "./config";

export interface DynamoDBTables {
  connectionsTable: aws.dynamodb.Table;
  pendingRequestsTable: aws.dynamodb.Table;
}

export function createDynamoDBTables(): DynamoDBTables {
  // Connections table
  const connectionsTable = new aws.dynamodb.Table("connections-table", {
    name: pulumi.interpolate`http-tunnel-connections-${tags.Environment}`,
    billingMode: "PAY_PER_REQUEST",
    hashKey: "connectionId",
    attributes: [
      { name: "connectionId", type: "S" },
      { name: "publicSubdomain", type: "S" },
    ],
    globalSecondaryIndexes: [
      {
        name: "subdomain-index",
        hashKey: "publicSubdomain",
        projectionType: "ALL",
      },
    ],
    ttl: {
      attributeName: "ttl",
      enabled: true,
    },
    tags: {
      ...tags,
      Name: "HTTP Tunnel Connections",
    },
  });

  // Pending requests table
  const pendingRequestsTable = new aws.dynamodb.Table("pending-requests-table", {
    name: pulumi.interpolate`http-tunnel-pending-requests-${tags.Environment}`,
    billingMode: "PAY_PER_REQUEST",
    hashKey: "requestId",
    attributes: [
      { name: "requestId", type: "S" },
    ],
    ttl: {
      attributeName: "ttl",
      enabled: true,
    },
    tags: {
      ...tags,
      Name: "HTTP Tunnel Pending Requests",
    },
  });

  return {
    connectionsTable,
    pendingRequestsTable,
  };
}
```

### src/iam.ts
```typescript
import * as aws from "@pulumi/aws";
import * as pulumi from "@pulumi/pulumi";
import { tags } from "./config";

export interface LambdaRoles {
  connectRole: aws.iam.Role;
  disconnectRole: aws.iam.Role;
  forwardingRole: aws.iam.Role;
  responseRole: aws.iam.Role;
}

const lambdaAssumeRolePolicy = aws.iam.assumeRolePolicyForPrincipal({
  Service: "lambda.amazonaws.com",
});

export function createLambdaRoles(
  connectionsTableArn: pulumi.Output<string>,
  pendingRequestsTableArn: pulumi.Output<string>,
  websocketApiArn: pulumi.Output<string>
): LambdaRoles {
  // Connect handler role
  const connectRole = new aws.iam.Role("connect-lambda-role", {
    assumeRolePolicy: lambdaAssumeRolePolicy,
    tags,
  });

  new aws.iam.RolePolicyAttachment("connect-lambda-basic-execution", {
    role: connectRole,
    policyArn: aws.iam.ManagedPolicies.AWSLambdaBasicExecutionRole,
  });

  new aws.iam.RolePolicy("connect-lambda-dynamodb-policy", {
    role: connectRole,
    policy: pulumi.interpolate`{
      "Version": "2012-10-17",
      "Statement": [
        {
          "Effect": "Allow",
          "Action": [
            "dynamodb:PutItem"
          ],
          "Resource": "${connectionsTableArn}"
        }
      ]
    }`,
  });

  // Disconnect handler role
  const disconnectRole = new aws.iam.Role("disconnect-lambda-role", {
    assumeRolePolicy: lambdaAssumeRolePolicy,
    tags,
  });

  new aws.iam.RolePolicyAttachment("disconnect-lambda-basic-execution", {
    role: disconnectRole,
    policyArn: aws.iam.ManagedPolicies.AWSLambdaBasicExecutionRole,
  });

  new aws.iam.RolePolicy("disconnect-lambda-dynamodb-policy", {
    role: disconnectRole,
    policy: pulumi.interpolate`{
      "Version": "2012-10-17",
      "Statement": [
        {
          "Effect": "Allow",
          "Action": [
            "dynamodb:DeleteItem"
          ],
          "Resource": "${connectionsTableArn}"
        }
      ]
    }`,
  });

  // Forwarding handler role
  const forwardingRole = new aws.iam.Role("forwarding-lambda-role", {
    assumeRolePolicy: lambdaAssumeRolePolicy,
    tags,
  });

  new aws.iam.RolePolicyAttachment("forwarding-lambda-basic-execution", {
    role: forwardingRole,
    policyArn: aws.iam.ManagedPolicies.AWSLambdaBasicExecutionRole,
  });

  new aws.iam.RolePolicy("forwarding-lambda-policy", {
    role: forwardingRole,
    policy: pulumi.all([
      connectionsTableArn,
      pendingRequestsTableArn,
      websocketApiArn,
    ]).apply(([connTableArn, pendingTableArn, wsApiArn]) => JSON.stringify({
      Version: "2012-10-17",
      Statement: [
        {
          Effect: "Allow",
          Action: [
            "dynamodb:Query",
          ],
          Resource: `${connTableArn}/index/subdomain-index`,
        },
        {
          Effect: "Allow",
          Action: [
            "dynamodb:PutItem",
            "dynamodb:GetItem",
            "dynamodb:DeleteItem",
          ],
          Resource: pendingTableArn,
        },
        {
          Effect: "Allow",
          Action: [
            "execute-api:ManageConnections",
          ],
          Resource: `${wsApiArn}/*`,
        },
      ],
    })),
  });

  // Response handler role
  const responseRole = new aws.iam.Role("response-lambda-role", {
    assumeRolePolicy: lambdaAssumeRolePolicy,
    tags,
  });

  new aws.iam.RolePolicyAttachment("response-lambda-basic-execution", {
    role: responseRole,
    policyArn: aws.iam.ManagedPolicies.AWSLambdaBasicExecutionRole,
  });

  new aws.iam.RolePolicy("response-lambda-dynamodb-policy", {
    role: responseRole,
    policy: pulumi.interpolate`{
      "Version": "2012-10-17",
      "Statement": [
        {
          "Effect": "Allow",
          "Action": [
            "dynamodb:UpdateItem"
          ],
          "Resource": "${pendingRequestsTableArn}"
        }
      ]
    }`,
  });

  return {
    connectRole,
    disconnectRole,
    forwardingRole,
    responseRole,
  };
}
```

### src/lambda.ts
```typescript
import * as aws from "@pulumi/aws";
import * as pulumi from "@pulumi/pulumi";
import { appConfig, tags } from "./config";
import { LambdaRoles } from "./iam";

export interface LambdaFunctions {
  connectHandler: aws.lambda.Function;
  disconnectHandler: aws.lambda.Function;
  forwardingHandler: aws.lambda.Function;
  responseHandler: aws.lambda.Function;
}

const lambdaCodePath = "../target/lambda";

export function createLambdaFunctions(
  roles: LambdaRoles,
  connectionsTableName: pulumi.Output<string>,
  pendingRequestsTableName: pulumi.Output<string>,
  websocketApiEndpoint: pulumi.Output<string>
): LambdaFunctions {
  const architecture = appConfig.lambdaArchitecture === "arm64" ? "arm64" : "x86_64";

  // Connect handler
  const connectHandler = new aws.lambda.Function("connect-handler", {
    name: pulumi.interpolate`http-tunnel-connect-${appConfig.environment}`,
    runtime: "provided.al2",
    handler: "bootstrap",
    role: roles.connectRole.arn,
    architectures: [architecture],
    memorySize: appConfig.lambdaMemorySize,
    timeout: 30,
    code: new pulumi.asset.FileArchive(`${lambdaCodePath}/connect`),
    environment: {
      variables: {
        RUST_LOG: "info",
        CONNECTIONS_TABLE_NAME: connectionsTableName,
        DOMAIN_NAME: appConfig.domainName,
      },
    },
    tags,
  });

  // Disconnect handler
  const disconnectHandler = new aws.lambda.Function("disconnect-handler", {
    name: pulumi.interpolate`http-tunnel-disconnect-${appConfig.environment}`,
    runtime: "provided.al2",
    handler: "bootstrap",
    role: roles.disconnectRole.arn,
    architectures: [architecture],
    memorySize: appConfig.lambdaMemorySize,
    timeout: 30,
    code: new pulumi.asset.FileArchive(`${lambdaCodePath}/disconnect`),
    environment: {
      variables: {
        RUST_LOG: "info",
        CONNECTIONS_TABLE_NAME: connectionsTableName,
      },
    },
    tags,
  });

  // Forwarding handler
  const forwardingHandler = new aws.lambda.Function("forwarding-handler", {
    name: pulumi.interpolate`http-tunnel-forwarding-${appConfig.environment}`,
    runtime: "provided.al2",
    handler: "bootstrap",
    role: roles.forwardingRole.arn,
    architectures: [architecture],
    memorySize: appConfig.lambdaMemorySize,
    timeout: appConfig.lambdaTimeout,
    code: new pulumi.asset.FileArchive(`${lambdaCodePath}/forwarding`),
    environment: {
      variables: {
        RUST_LOG: "info",
        CONNECTIONS_TABLE_NAME: connectionsTableName,
        PENDING_REQUESTS_TABLE_NAME: pendingRequestsTableName,
        WEBSOCKET_API_ENDPOINT: websocketApiEndpoint,
      },
    },
    tags,
  });

  // Response handler
  const responseHandler = new aws.lambda.Function("response-handler", {
    name: pulumi.interpolate`http-tunnel-response-${appConfig.environment}`,
    runtime: "provided.al2",
    handler: "bootstrap",
    role: roles.responseRole.arn,
    architectures: [architecture],
    memorySize: appConfig.lambdaMemorySize,
    timeout: 30,
    code: new pulumi.asset.FileArchive(`${lambdaCodePath}/response`),
    environment: {
      variables: {
        RUST_LOG: "info",
        PENDING_REQUESTS_TABLE_NAME: pendingRequestsTableName,
      },
    },
    tags,
  });

  return {
    connectHandler,
    disconnectHandler,
    forwardingHandler,
    responseHandler,
  };
}
```

### src/apigateway.ts
```typescript
import * as aws from "@pulumi/aws";
import * as pulumi from "@pulumi/pulumi";
import { appConfig, tags } from "./config";
import { LambdaFunctions } from "./lambda";

export interface ApiGateways {
  websocketApi: aws.apigatewayv2.Api;
  httpApi: aws.apigatewayv2.Api;
  websocketStage: aws.apigatewayv2.Stage;
  httpStage: aws.apigatewayv2.Stage;
  websocketEndpoint: pulumi.Output<string>;
  httpEndpoint: pulumi.Output<string>;
}

export function createApiGateways(
  lambdas: LambdaFunctions
): ApiGateways {
  // ===== WebSocket API =====
  const websocketApi = new aws.apigatewayv2.Api("websocket-api", {
    name: pulumi.interpolate`http-tunnel-ws-${appConfig.environment}`,
    protocolType: "WEBSOCKET",
    routeSelectionExpression: "$request.body.action",
    tags,
  });

  // $connect route
  const connectIntegration = new aws.apigatewayv2.Integration("connect-integration", {
    apiId: websocketApi.id,
    integrationType: "AWS_PROXY",
    integrationUri: lambdas.connectHandler.invokeArn,
  });

  const connectRoute = new aws.apigatewayv2.Route("connect-route", {
    apiId: websocketApi.id,
    routeKey: "$connect",
    target: pulumi.interpolate`integrations/${connectIntegration.id}`,
  });

  new aws.lambda.Permission("connect-lambda-permission", {
    action: "lambda:InvokeFunction",
    function: lambdas.connectHandler.name,
    principal: "apigateway.amazonaws.com",
    sourceArn: pulumi.interpolate`${websocketApi.executionArn}/*`,
  });

  // $disconnect route
  const disconnectIntegration = new aws.apigatewayv2.Integration("disconnect-integration", {
    apiId: websocketApi.id,
    integrationType: "AWS_PROXY",
    integrationUri: lambdas.disconnectHandler.invokeArn,
  });

  const disconnectRoute = new aws.apigatewayv2.Route("disconnect-route", {
    apiId: websocketApi.id,
    routeKey: "$disconnect",
    target: pulumi.interpolate`integrations/${disconnectIntegration.id}`,
  });

  new aws.lambda.Permission("disconnect-lambda-permission", {
    action: "lambda:InvokeFunction",
    function: lambdas.disconnectHandler.name,
    principal: "apigateway.amazonaws.com",
    sourceArn: pulumi.interpolate`${websocketApi.executionArn}/*`,
  });

  // $default route
  const responseIntegration = new aws.apigatewayv2.Integration("response-integration", {
    apiId: websocketApi.id,
    integrationType: "AWS_PROXY",
    integrationUri: lambdas.responseHandler.invokeArn,
  });

  const defaultRoute = new aws.apigatewayv2.Route("default-route", {
    apiId: websocketApi.id,
    routeKey: "$default",
    target: pulumi.interpolate`integrations/${responseIntegration.id}`,
  });

  new aws.lambda.Permission("response-lambda-permission", {
    action: "lambda:InvokeFunction",
    function: lambdas.responseHandler.name,
    principal: "apigateway.amazonaws.com",
    sourceArn: pulumi.interpolate`${websocketApi.executionArn}/*`,
  });

  // WebSocket stage
  const websocketStage = new aws.apigatewayv2.Stage("websocket-stage", {
    apiId: websocketApi.id,
    name: appConfig.environment,
    autoDeploy: true,
    tags,
  });

  // ===== HTTP API =====
  const httpApi = new aws.apigatewayv2.Api("http-api", {
    name: pulumi.interpolate`http-tunnel-http-${appConfig.environment}`,
    protocolType: "HTTP",
    tags,
  });

  const forwardingIntegration = new aws.apigatewayv2.Integration("forwarding-integration", {
    apiId: httpApi.id,
    integrationType: "AWS_PROXY",
    integrationUri: lambdas.forwardingHandler.invokeArn,
    payloadFormatVersion: "2.0",
    timeoutMilliseconds: 29000, // Just under 30s limit
  });

  const catchAllRoute = new aws.apigatewayv2.Route("catchall-route", {
    apiId: httpApi.id,
    routeKey: "$default",
    target: pulumi.interpolate`integrations/${forwardingIntegration.id}`,
  });

  new aws.lambda.Permission("forwarding-lambda-permission", {
    action: "lambda:InvokeFunction",
    function: lambdas.forwardingHandler.name,
    principal: "apigateway.amazonaws.com",
    sourceArn: pulumi.interpolate`${httpApi.executionArn}/*`,
  });

  // HTTP stage
  const httpStage = new aws.apigatewayv2.Stage("http-stage", {
    apiId: httpApi.id,
    name: appConfig.environment,
    autoDeploy: true,
    tags,
  });

  const websocketEndpoint = pulumi.interpolate`wss://${websocketApi.id}.execute-api.${appConfig.awsRegion}.amazonaws.com/${websocketStage.name}`;
  const httpEndpoint = pulumi.interpolate`https://${httpApi.id}.execute-api.${appConfig.awsRegion}.amazonaws.com`;

  return {
    websocketApi,
    httpApi,
    websocketStage,
    httpStage,
    websocketEndpoint,
    httpEndpoint,
  };
}
```

### src/domain.ts
```typescript
import * as aws from "@pulumi/aws";
import * as pulumi from "@pulumi/pulumi";
import { appConfig, tags } from "./config";

export interface CustomDomain {
  domainName: aws.apigatewayv2.DomainName;
  apiMapping: aws.apigatewayv2.ApiMapping;
}

export function createCustomDomain(
  httpApiId: pulumi.Output<string>,
  httpStageId: pulumi.Output<string>
): CustomDomain | undefined {
  if (!appConfig.enableCustomDomain) {
    return undefined;
  }

  if (!appConfig.certificateArn) {
    throw new Error("Certificate ARN is required when custom domain is enabled");
  }

  // Wildcard domain name for subdomains
  const wildcardDomain = `*.${appConfig.domainName}`;

  const domainName = new aws.apigatewayv2.DomainName("custom-domain", {
    domainName: wildcardDomain,
    domainNameConfiguration: {
      certificateArn: appConfig.certificateArn,
      endpointType: "REGIONAL",
      securityPolicy: "TLS_1_2",
    },
    tags,
  });

  const apiMapping = new aws.apigatewayv2.ApiMapping("api-mapping", {
    apiId: httpApiId,
    domainName: domainName.id,
    stage: httpStageId,
  });

  return {
    domainName,
    apiMapping,
  };
}
```

### index.ts
```typescript
import * as pulumi from "@pulumi/pulumi";
import { createDynamoDBTables } from "./src/dynamodb";
import { createLambdaRoles } from "./src/iam";
import { createLambdaFunctions } from "./src/lambda";
import { createApiGateways } from "./src/apigateway";
import { createCustomDomain } from "./src/domain";
import { appConfig } from "./src/config";

// Create DynamoDB tables
const { connectionsTable, pendingRequestsTable } = createDynamoDBTables();

// Create API Gateways (needed for IAM roles)
// Create temporary structure for roles
const websocketApiArnPlaceholder = pulumi.output("arn:aws:execute-api:*:*:*");

// Create IAM roles
const roles = createLambdaRoles(
  connectionsTable.arn,
  pendingRequestsTable.arn,
  websocketApiArnPlaceholder
);

// Create API Gateways
const apis = createApiGateways({
  connectHandler: undefined as any,
  disconnectHandler: undefined as any,
  forwardingHandler: undefined as any,
  responseHandler: undefined as any,
});

// Update IAM roles with actual WebSocket API ARN
const updatedRoles = createLambdaRoles(
  connectionsTable.arn,
  pendingRequestsTable.arn,
  apis.websocketApi.executionArn
);

// Create Lambda functions
const lambdas = createLambdaFunctions(
  updatedRoles,
  connectionsTable.name,
  pendingRequestsTable.name,
  pulumi.interpolate`https://${apis.websocketApi.id}.execute-api.${appConfig.awsRegion}.amazonaws.com/${apis.websocketStage.name}`
);

// Create actual API Gateways with Lambdas
const finalApis = createApiGateways(lambdas);

// Create custom domain (optional)
const customDomain = createCustomDomain(
  finalApis.httpApi.id,
  finalApis.httpStage.id
);

// Exports
export const connectionsTableName = connectionsTable.name;
export const pendingRequestsTableName = pendingRequestsTable.name;
export const websocketEndpoint = finalApis.websocketEndpoint;
export const httpEndpoint = finalApis.httpEndpoint;
export const websocketApiId = finalApis.websocketApi.id;
export const httpApiId = finalApis.httpApi.id;

if (customDomain) {
  export const customDomainName = customDomain.domainName.domainName;
  export const customDomainTarget = customDomain.domainName.domainNameConfiguration.targetDomainName;
}
```

### package.json
```json
{
  "name": "http-tunnel-infra",
  "version": "1.0.0",
  "description": "HTTP Tunnel Infrastructure",
  "main": "index.ts",
  "scripts": {
    "build": "tsc",
    "deploy": "pulumi up",
    "destroy": "pulumi destroy",
    "preview": "pulumi preview"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "typescript": "^5.3.0"
  },
  "dependencies": {
    "@pulumi/pulumi": "^3.100.0",
    "@pulumi/aws": "^6.20.0"
  }
}
```

### tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "resolveJsonModule": true
  },
  "include": ["**/*.ts"],
  "exclude": ["node_modules", "dist"]
}
```

## Deployment Process

### Prerequisites
```bash
# Install Pulumi
curl -fsSL https://get.pulumi.com | sh

# Install Node.js dependencies
cd infra
npm install

# Configure AWS credentials
aws configure

# Login to Pulumi
pulumi login
```

### Build Lambda Functions
```bash
# Build all Lambda binaries
cargo lambda build --release --bin connect --bin disconnect --bin forwarding --bin response

# Package into deployment directories
mkdir -p target/lambda/{connect,disconnect,forwarding,response}
cp target/lambda/release/connect target/lambda/connect/bootstrap
cp target/lambda/release/disconnect target/lambda/disconnect/bootstrap
cp target/lambda/release/forwarding target/lambda/forwarding/bootstrap
cp target/lambda/release/response target/lambda/response/bootstrap
```

### Deploy Infrastructure
```bash
# Initialize stack
pulumi stack init dev

# Set configuration
pulumi config set aws:region us-east-1
pulumi config set http-tunnel:domainName tunnel.dev.example.com
pulumi config set http-tunnel:environment dev

# Preview changes
pulumi preview

# Deploy
pulumi up

# Get outputs
pulumi stack output
```

### Update Deployment
```bash
# Rebuild Rust code
cargo lambda build --release

# Update infrastructure
pulumi up
```

### Destroy Infrastructure
```bash
pulumi destroy
```

## Makefile Integration

Add to root `Makefile`:

```makefile
.PHONY: build-lambda deploy-infra destroy-infra preview-infra

build-lambda:
	cargo lambda build --release --bin connect --bin disconnect --bin forwarding --bin response
	mkdir -p target/lambda/{connect,disconnect,forwarding,response}
	cp target/lambda/release/connect target/lambda/connect/bootstrap
	cp target/lambda/release/disconnect target/lambda/disconnect/bootstrap
	cp target/lambda/release/forwarding target/lambda/forwarding/bootstrap
	cp target/lambda/release/response target/lambda/response/bootstrap

deploy-infra: build-lambda
	cd infra && pulumi up -y

destroy-infra:
	cd infra && pulumi destroy -y

preview-infra:
	cd infra && pulumi preview
```

## Monitoring and Observability

### CloudWatch Alarms
```typescript
// Add to index.ts
import * as aws from "@pulumi/aws";

// Lambda error alarm
new aws.cloudwatch.MetricAlarm("lambda-errors", {
  alarmName: "http-tunnel-lambda-errors",
  comparisonOperator: "GreaterThanThreshold",
  evaluationPeriods: 1,
  metricName: "Errors",
  namespace: "AWS/Lambda",
  period: 300,
  statistic: "Sum",
  threshold: 10,
  alarmDescription: "Alert when Lambda errors exceed threshold",
  dimensions: {
    FunctionName: lambdas.forwardingHandler.name,
  },
});

// DynamoDB throttles
new aws.cloudwatch.MetricAlarm("dynamodb-throttles", {
  alarmName: "http-tunnel-dynamodb-throttles",
  comparisonOperator: "GreaterThanThreshold",
  evaluationPeriods: 1,
  metricName: "UserErrors",
  namespace: "AWS/DynamoDB",
  period: 300,
  statistic: "Sum",
  threshold: 5,
  alarmDescription: "Alert when DynamoDB throttles occur",
  dimensions: {
    TableName: connectionsTable.name,
  },
});
```

## Cost Optimization

1. **Use ARM64 architecture** for Lambda (better price/performance)
2. **Enable DynamoDB on-demand billing** for unpredictable workloads
3. **Set appropriate Lambda memory sizes** based on testing
4. **Use Lambda provisioned concurrency** only if needed
5. **Enable CloudWatch Logs retention** to avoid unbounded costs

## Security Hardening

1. **Enable VPC endpoints** for DynamoDB and Lambda
2. **Use AWS WAF** on HTTP API Gateway
3. **Enable API Gateway access logging**
4. **Use Secrets Manager** for sensitive configuration
5. **Enable CloudTrail** for audit logging

## CI/CD Integration

### GitHub Actions Example
```yaml
name: Deploy Infrastructure

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable

      - name: Install cargo-lambda
        run: cargo install cargo-lambda

      - name: Build Lambda functions
        run: make build-lambda

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install Pulumi
        uses: pulumi/actions@v4

      - name: Deploy infrastructure
        run: cd infra && pulumi up -y
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
```
