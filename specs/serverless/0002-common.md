# Common Data Structures and Utilities

## Overview
This specification defines the shared data structures, protocols, and utilities used by both the forwarder (client agent) and handler (Lambda functions). The common crate serves as the foundation for communication and data exchange.

## Core Data Structures

### 1. Message Protocol Envelope

All WebSocket messages are wrapped in a typed envelope to distinguish between different message types:

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum Message {
    // Control plane messages
    Ping,
    Pong,

    // Connection lifecycle
    ConnectionEstablished {
        connection_id: String,
        public_subdomain: String,
        public_url: String,
    },

    // Data plane messages
    HttpRequest(HttpRequest),
    HttpResponse(HttpResponse),

    // Error handling
    Error {
        request_id: Option<String>,
        code: ErrorCode,
        message: String,
    },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ErrorCode {
    #[serde(rename = "invalid_request")]
    InvalidRequest,
    #[serde(rename = "timeout")]
    Timeout,
    #[serde(rename = "local_service_unavailable")]
    LocalServiceUnavailable,
    #[serde(rename = "internal_error")]
    InternalError,
}
```

### 2. HTTP Request Payload

Represents an HTTP request forwarded from the public endpoint to the agent:

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HttpRequest {
    /// Unique identifier to correlate request and response
    pub request_id: String,

    /// HTTP method (GET, POST, PUT, DELETE, etc.)
    pub method: String,

    /// Request URI including path and query string
    /// Example: "/api/v1/users?limit=10"
    pub uri: String,

    /// HTTP headers as a map of header name to list of values
    /// Multiple values per header are supported
    pub headers: HashMap<String, Vec<String>>,

    /// Request body encoded in Base64
    /// Empty string for requests without body
    #[serde(default)]
    pub body: String,

    /// Timestamp when request was received (Unix epoch in milliseconds)
    pub timestamp: u64,
}
```

**Design Rationale:**
- `request_id`: Generated by ForwardingHandler, used to correlate async request/response cycle
- `headers`: HashMap with Vec values to support multiple values per header (e.g., multiple `Cookie` headers)
- `body`: Base64-encoded to safely transmit binary data through JSON
- `timestamp`: For timeout detection and metrics

### 3. HTTP Response Payload

Represents the response from the local service, sent back through the tunnel:

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HttpResponse {
    /// Must match the request_id from the corresponding HttpRequest
    pub request_id: String,

    /// HTTP status code (200, 404, 500, etc.)
    pub status_code: u16,

    /// Response headers as a map of header name to list of values
    pub headers: HashMap<String, Vec<String>>,

    /// Response body encoded in Base64
    #[serde(default)]
    pub body: String,

    /// Processing time in milliseconds (local service response time)
    #[serde(default)]
    pub processing_time_ms: u64,
}
```

### 4. Connection Metadata

Used by Lambda functions to track active connections in DynamoDB:

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionMetadata {
    /// API Gateway WebSocket connection ID
    pub connection_id: String,

    /// Unique public subdomain assigned to this connection
    pub public_subdomain: String,

    /// Full public URL (https://{subdomain}.{domain})
    pub public_url: String,

    /// Timestamp when connection was established (Unix epoch seconds)
    pub created_at: i64,

    /// TTL timestamp for DynamoDB auto-deletion (Unix epoch seconds)
    pub ttl: i64,

    /// Optional metadata about the client
    #[serde(default)]
    pub client_info: Option<ClientInfo>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClientInfo {
    pub version: String,
    pub platform: String,
}
```

### 5. Pending Request State

Used to track in-flight requests waiting for responses:

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PendingRequest {
    /// Unique request identifier
    pub request_id: String,

    /// Connection ID that should handle this request
    pub connection_id: String,

    /// Original API Gateway request context (for response)
    pub api_gateway_request_id: String,

    /// Timestamp when request was forwarded (Unix epoch seconds)
    pub created_at: i64,

    /// TTL for auto-cleanup (Unix epoch seconds)
    /// Should be short-lived (e.g., 30 seconds)
    pub ttl: i64,
}
```

## Utility Functions

### 1. Subdomain Generation

```rust
use rand::{thread_rng, Rng};
use rand::distributions::Alphanumeric;

/// Generate a random, URL-safe subdomain
/// Format: 12 lowercase alphanumeric characters
pub fn generate_subdomain() -> String {
    thread_rng()
        .sample_iter(&Alphanumeric)
        .take(12)
        .map(|c| c.to_ascii_lowercase())
        .map(char::from)
        .collect()
}
```

### 2. Request ID Generation

```rust
use uuid::Uuid;

/// Generate a unique request identifier using UUID v4
pub fn generate_request_id() -> String {
    Uuid::new_v4().to_string()
}
```

### 3. Base64 Encoding/Decoding

```rust
use base64::{Engine as _, engine::general_purpose::STANDARD};

/// Encode bytes to Base64 string
pub fn encode_body(body: &[u8]) -> String {
    STANDARD.encode(body)
}

/// Decode Base64 string to bytes
pub fn decode_body(encoded: &str) -> Result<Vec<u8>, base64::DecodeError> {
    STANDARD.decode(encoded)
}
```

### 4. Timestamp Utilities

```rust
use std::time::{SystemTime, UNIX_EPOCH};

/// Get current Unix timestamp in seconds
pub fn current_timestamp_secs() -> i64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards")
        .as_secs() as i64
}

/// Get current Unix timestamp in milliseconds
pub fn current_timestamp_millis() -> u64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards")
        .as_millis() as u64
}

/// Calculate TTL timestamp (current time + duration in seconds)
pub fn calculate_ttl(duration_secs: i64) -> i64 {
    current_timestamp_secs() + duration_secs
}
```

### 5. HTTP Header Conversion

```rust
use std::collections::HashMap;

/// Convert HTTP headers to our internal format
/// Supports multiple values per header name
pub fn headers_to_map(headers: &http::HeaderMap) -> HashMap<String, Vec<String>> {
    let mut map: HashMap<String, Vec<String>> = HashMap::new();

    for (name, value) in headers.iter() {
        let key = name.as_str().to_string();
        let val = value.to_str().unwrap_or("").to_string();

        map.entry(key)
            .or_insert_with(Vec::new)
            .push(val);
    }

    map
}

/// Convert our internal header format to HTTP HeaderMap
pub fn map_to_headers(map: &HashMap<String, Vec<String>>) -> http::HeaderMap {
    let mut headers = http::HeaderMap::new();

    for (name, values) in map.iter() {
        if let Ok(header_name) = http::header::HeaderName::from_bytes(name.as_bytes()) {
            for value in values {
                if let Ok(header_value) = http::header::HeaderValue::from_str(value) {
                    headers.append(header_name.clone(), header_value);
                }
            }
        }
    }

    headers
}
```

## Error Types

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum TunnelError {
    #[error("Invalid message format: {0}")]
    InvalidMessage(String),

    #[error("Connection error: {0}")]
    ConnectionError(String),

    #[error("Timeout waiting for response")]
    Timeout,

    #[error("Local service unavailable: {0}")]
    LocalServiceUnavailable(String),

    #[error("DynamoDB error: {0}")]
    DynamoDbError(String),

    #[error("WebSocket error: {0}")]
    WebSocketError(String),

    #[error("Serialization error: {0}")]
    SerializationError(#[from] serde_json::Error),

    #[error("Base64 decode error: {0}")]
    Base64Error(#[from] base64::DecodeError),

    #[error("HTTP error: {0}")]
    HttpError(String),

    #[error("Internal error: {0}")]
    InternalError(String),
}

pub type Result<T> = std::result::Result<T, TunnelError>;
```

## Configuration Constants

```rust
/// Maximum connection lifetime before requiring reconnection
pub const MAX_CONNECTION_LIFETIME_SECS: i64 = 7200; // 2 hours

/// DynamoDB TTL buffer (cleanup old connections)
pub const CONNECTION_TTL_SECS: i64 = 7200; // 2 hours

/// Heartbeat interval to keep WebSocket alive
pub const HEARTBEAT_INTERVAL_SECS: u64 = 300; // 5 minutes

/// API Gateway WebSocket idle timeout
pub const WEBSOCKET_IDLE_TIMEOUT_SECS: u64 = 600; // 10 minutes

/// Request timeout waiting for response from agent
pub const REQUEST_TIMEOUT_SECS: u64 = 25; // Under API Gateway's 29s limit

/// Pending request TTL in DynamoDB
pub const PENDING_REQUEST_TTL_SECS: i64 = 30;

/// Maximum request/response body size (6 MB per API Gateway limit)
pub const MAX_BODY_SIZE_BYTES: usize = 6 * 1024 * 1024;

/// Exponential backoff settings for reconnection
pub const RECONNECT_MIN_DELAY_MS: u64 = 1000;    // 1 second
pub const RECONNECT_MAX_DELAY_MS: u64 = 60000;   // 60 seconds
pub const RECONNECT_MULTIPLIER: f64 = 2.0;
```

## Dependencies Required

Add to `crates/common/Cargo.toml`:

```toml
[dependencies]
anyhow.workspace = true
serde = { workspace = true, features = ["derive"] }
serde_json.workspace = true
thiserror.workspace = true
tokio.workspace = true

# Additional dependencies
base64 = "0.22"
uuid = { version = "1.11", features = ["v4", "serde"] }
http = "1.2"
rand = "0.8"
```

## Module Organization

```
crates/common/src/
├── lib.rs           # Re-exports and module declarations
├── protocol/        # Message protocol definitions
│   ├── mod.rs
│   ├── message.rs   # Message enum
│   ├── request.rs   # HttpRequest
│   └── response.rs  # HttpResponse
├── models/          # Data models
│   ├── mod.rs
│   ├── connection.rs   # ConnectionMetadata
│   └── pending.rs      # PendingRequest
├── utils/           # Utility functions
│   ├── mod.rs
│   ├── encoding.rs  # Base64 helpers
│   ├── headers.rs   # HTTP header conversion
│   ├── id.rs        # ID generation
│   └── time.rs      # Timestamp utilities
├── error.rs         # Error types
└── constants.rs     # Configuration constants
```

## Testing Strategy

### Unit Tests

- Test message serialization/deserialization with various payloads
- Test Base64 encoding/decoding with binary data
- Test header conversion with edge cases (empty values, special characters)
- Test subdomain generation for uniqueness and format
- Test timestamp utilities for correctness

### Integration Tests

- Test full request/response cycle serialization
- Test error message propagation
- Test header preservation through conversion
- Test large payload handling (up to MAX_BODY_SIZE_BYTES)

## Security Considerations

1. **Input Validation**: All deserialized data should be validated before use
2. **Size Limits**: Enforce MAX_BODY_SIZE_BYTES to prevent memory exhaustion
3. **Header Sanitization**: Filter out sensitive headers before logging
4. **Request ID Uniqueness**: Use UUIDs to prevent collision attacks
5. **Base64 Validation**: Validate Base64 strings before decoding

## Performance Considerations

1. **Zero-Copy**: Use references where possible to avoid unnecessary clones
2. **Lazy Decoding**: Don't decode Base64 bodies until needed
3. **Header Maps**: Use efficient HashMap implementation
4. **Serialization**: Use serde's efficient JSON serialization
5. **Connection Pooling**: Reuse HTTP client connections in forwarder
